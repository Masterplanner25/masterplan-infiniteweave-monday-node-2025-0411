import logging
import threading
from fastapi import FastAPI
from fastapi_cache import FastAPICache
from fastapi_cache.backends.inmemory import InMemoryBackend
from fastapi.middleware.cors import CORSMiddleware
from services import task_services
from db.database import SessionLocal
from routes import ROUTERS
from db.models.metrics_models import *

# --- Ensure root path is importable ---
import sys, os
ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
if ROOT_DIR not in sys.path:
    sys.path.insert(0, ROOT_DIR)


# For in-memory caching
# If you want to use Redis (uncomment and configure):
# from fastapi_cache.backends.redis import RedisBackend
# from redis import asyncio as aioredis


# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

app = FastAPI(title="A.I.N.D.Y. Memory Bridge")

for route in ROUTERS:
    app.include_router(route)

# CORS (Cross-Origin Resource Sharing) for frontend integration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.middleware("http")
async def log_requests(request, call_next):
    logger.info(f"Request: {request.method} {request.url}")
    response = await call_next(request)
    logger.info(f"Response: {response.status_code}")
    return response

@app.on_event("startup")
async def startup():
    # Initialize cache
    FastAPICache.init(InMemoryBackend(), prefix="fastapi-cache")

    # Create a DB session
    db = SessionLocal()

    # --- Background thread functions ---
    def handle_recurrence(*args, **kwargs):
        logger.info("[Recurrence] Checking completed tasks for recurrence...")
        # Add real logic here
        logger.info("[Recurrence] Cycle complete.")

    def check_reminders(*args, **kwargs):
        logger.info("[Reminders] Checking pending reminders...")
        # Add real logic here
        logger.info("[Reminders] Check complete.")

    # --- Start background threads ---
    threading.Thread(target=handle_recurrence, daemon=True).start()
    threading.Thread(target=check_reminders, daemon=True).start()

    logger.info("Background tasks initialized (ok).")


    # To use Redis, uncomment the following and adjust the Redis URL:
    # redis = aioredis.from_url("redis://localhost")
    # FastAPICache.init(RedisBackend(redis), prefix="fastapi-cache")

# ---------------------------------------------------------------------------
#  SYSTEM IDENTITY SEEDER
# ---------------------------------------------------------------------------
@app.on_event("startup")
def ensure_system_identity():
    """
    Guarantee that the A.I.N.D.Y. system identity exists in the authors table.
    """
    from db.database import SessionLocal
    from db.models.author_model import AuthorDB
    from datetime import datetime

    db = SessionLocal()
    system_id = "author-system"

    existing = db.query(AuthorDB).filter_by(id=system_id).first()
    if not existing:
        system_author = AuthorDB(
            id=system_id,
            name="A.I.N.D.Y. System",
            platform="Internal Core",
            notes="Autogenerated identity for runtime self-reference.",
            joined_at=datetime.utcnow(),
            last_seen=datetime.utcnow(),
        )
        db.add(system_author)
        db.commit()
        print("üß† Seeded system author: A.I.N.D.Y. System")
    else:
        existing.last_seen = datetime.utcnow()
        db.commit()
        print("üîÅ System author already present, timestamp refreshed.")
    db.close()

@app.get("/")
def home():
    return {"message": "A.I.N.D.Y. API is running!"}